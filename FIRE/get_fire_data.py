# GET FIRE DATA FROM AICC ALASKA FIRE REST SERVICES
import requests

class FireData( object ):
	def __init__( self, baseurl, *args, **kwargs ):
		'''
		return fire data from ESRI REST services at AICC

		ARGUMENTS:
		----------
		baseurl = [str] url to the base ESRI REST service.

		** for AICC holdings an example is as follows:
		'http://afs.ak.blm.gov/arcgis/rest/services/MapAndFeatureServices/\n
					CurrentFiresService/MapServer'
		RETURNS:
		--------
		object of type FireData containing the following attributes:
		[ baseurl, layers, queryurl, dat, fields, meta, json ]

		'''
		self.baseurl = baseurl
		self.layers = self._discover_layers()
		self.queryurl = None
		self.dat = None
		self.fields = None
		self.meta = None
		self.json = None

	def _discover_layers( self ):
		''' 
		return a dict of the available layers and their identifiers.
		this is useful for the discovery of what layer id's to use in
		FireData.get_data( )
		'''
		r = requests.get( self.baseurl + '/'+ 'layers', params={'f':'pjson'} )
		return { i['id']:i['name'] for i in r.json()[ 'layers' ] }
	def get_meta( self, layerid=0, params={'f':'pjson'} ):
		'''
		return layer metadata including FIELDS which is useful for 
		crafting the `outFields` {'key':'value'} pair which will tell
		the service what fields to return. There can be an abundance.

		ARGUMENTS:
		----------
		layerid = [int] id of the layer to select from. default:0
		params = [dict] default:{'f':'pjson'} which tells to 
					return as json.  

		RETURNS:
		--------
		self.meta and self.fields, where self.meta has all metadata as json
		about the layer being queried and self.fields containing a list of dicts
		containing attributes of the fields.

		'''
		path = '/'.join([ self.baseurl, str( layerid ) ])
		r = requests.get( path,  params=params )
		self.meta = r.json()
		self.fields = r.json()[ 'fields' ]
	def get_data( self, layerid=0, params={'where':''}, crs=3572 ):
		'''
		make a request to the AICC REST services with a query dict of 
		{key:value} pairs of search parameters.  

		ARGUMENTS:
		----------
		layerid = [int] id of the layer to select from
		params = [dict] dict of {'key':'value'} pairs of search parameters
					to pass to the REST service.
		crs = [int] EPSG code for the reference system to return the data in.

		RETURNS:
		--------
		self.dat & self.json where .dat is the returned `requests` get object
		and .json is the dat.json() helper.

		'''
		path = '/'.join([ self.baseurl, str( layerid ), 'query' ])
		r = requests.get( path, params=params )
		self.dat = r
		self.json = self.dat.json()

def run( output_directory, service, group, fmat='ESRI Shapefile', ext='.shp' ):
	import os
	# use the url generated by requests to issue a system command using subprocess
	# output_filename = out_json.name.replace( '.json', ext.replace('.', '.') )
	output_filename = os.path.join( output_directory, '_'.join([ service.lower(), '2016', group ]) + ext )
	if os.path.exists( output_filename ):
		os.remove( output_filename )

	_ = subprocess.call([ 'ogr2ogr', '-f', fmat, output_filename, f.dat.url ])
	return output_filename

def run2( output_directory, baseurl, whereclause, service, group, fmat='ESRI Shapefile', ext='.shp' ):
	import os
	import arcgis
	# use the url generated by requests to issue a system command using subprocess
	# output_filename = out_json.name.replace( '.json', ext.replace('.', '.') )
	output_filename = os.path.join( output_directory, '_'.join([ service.lower(), '2016', group ]) + ext )
	if os.path.exists( output_filename ):
		os.remove( output_filename )

	source = arcgis.ArcGIS( baseurl )
	tmp_file = os.path.join( output_directory, 'TMP_REMOVE_ME.json' )

	# since GeoJSON cannot overwrite existing files...
	if os.path.exists( tmp_file ):
		os.unlink( tmp_file )

	if os.path.exists( output_filename ):
		os.unlink( output_filename )

	with open( tmp_file, 'w' ) as out_json:
		json.dump( source.get( groups[ group ], whereclause ), out_json )

	# convert to the proper system? -- HACKY!!! 
	os.system( 'ogr2ogr -f GeoJSON -t_srs EPSG:3338 ' + output_filename + ' ' + tmp_file )
	os.unlink( tmp_file )

	return output_filename

if __name__ == '__main__':
	# run an example query for the available fire perimeters for this season
	import requests, subprocess, json, collections
	import numpy as np
	import argparse
	import os

	# parse commandline args
	# output_directory = '/workspace/Shared/Tech_Projects/FireMap/project_data/fireseason_2016' # '/Users/malindgren/Documents/firemap/fire_2016'
	parser = argparse.ArgumentParser( description='GET FIRE DATA FROM THE AICC REST SERVICES' )
	parser.add_argument( '-p', '--output_directory', action='store', dest='output_directory', type=str, help='path to output directory' )
	
	args = parser.parse_args()
	output_directory = args.output_directory

	services = {'FirePerimeters':"FIREYEAR='2016'", 'Fires':"FIRESEASON='2016'"}
	groups = {'active':0,'all':1}
	for service in services:
		for group in groups:
			baseurl = '/'.join([ 'http://afs.ak.blm.gov/arcgis/rest/services/MapAndFeatureServices',service,'MapServer' ])
			whereclause = services[ service ] #"FIREYEAR='2016'"
			out_wkt = 'PROJCS["NAD_1983_Alaska_Albers",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-154.0],PARAMETER["Standard_Parallel_1",55.0],PARAMETER["Standard_Parallel_2",65.0],PARAMETER["Latitude_Of_Origin",50.0],UNIT["Meter",1.0]]'
			outSR = '3338'
			# REST key:vals available for use when interacting with the service
			#   * info on the rest service from ESRI: http://resources.arcgis.com/en/help/rest/apiref/mapserver.html
			#   * QUERY params docs: http://resources.arcgis.com/en/help/rest/apiref/query.html
			QUERY = {'where' : whereclause,
					'text' : '',
					'objectIds' : '',
					'time' : '',
					'geometry' : '',
					'geometryType' : 'esriGeometryEnvelope',
					'inSR' : '',
					'spatialRel' : 'esriSpatialRelIntersects',
					'relationParam' : '',
					'outFields' : '*',
					'returnGeometry' : 'true',
					'maxAllowableOffset' : '',
					'geometryPrecision' : '',
					'outSR' : '',
					'returnIdsOnly' : 'false',
					'returnCountOnly' : 'false',
					'orderByFields' : '',
					'groupByFieldsForStatistics' : '',
					'outStatistics' : '',
					'returnZ' : 'false',
					'returnM' : 'false',
					'gdbVersion' : '',
					'returnDistinctValues' : 'false',
					'returnTrueCurves' : 'false',
					'resultOffset' : '',
					'resultRecordCount' : '',
					'f' : 'pjson' }
			
			# old way to build query, but we are using requests instead
			# keyvals = [ '='.join([ key, QUERY[ key ] ]) for key in QUERY if len(QUERY[key]) > 0 ]
			# query_for_json = base_url + '&'.join( keyvals )

			# instantiate FireData object
			f = FireData( baseurl )

			# after inspecting layers available choose a layerid
			layerid = groups[ group ]

			# [OPTIONAL] return a dict of meta information about the layer of interest
			f.get_meta( layerid=layerid )

			f.get_data( layerid, QUERY )

			# run( output_directory, service, group, fmat='ESRI Shapefile', ext='.shp' )
			run2( output_directory, baseurl, whereclause, service, group, fmat='GeoJSON', ext='.json' )

	# clean - join perims
	os.chdir( output_directory )
	os.system( 'python ../clean_join_perims_points.py ' + '-pts ' + 'fires_2016_all.json' + ' -pall ' + 'fireperimeters_2016_all.json' +  ' -pactive ' + 'fireperimeters_2016_active.json' + ' -p ' + output_directory )
	
	perim_prj = 'fireperimeters_2016_all_cleaned_joined.prj'
	with open( perim_prj, 'w' ) as out:
		out.write( out_wkt )

	pts_prj = 'fires_2016_cleaned_noperim.prj'
	with open( perim_prj, 'w' ) as out:
		out.write( out_wkt )

	# this can be used to run the query and output to GeoJSON if an old version of GDAL/OGR is being used without dates update
	# run2( output_directory, baseurl, whereclause, service, group, fmat='GeoJSON', ext='.json' )

	# convert to GeoJSON? -- done
	# ogr2ogr -f GeoJSON fire_perimeters_2016_all.json http://afs.ak.blm.gov/arcgis/rest/services/MapAndFeatureServices/FirePerimeters/MapServer/1/query\?where\=FIREYEAR+%3D%272016%27\&outFields\=\*\&f\=pjson

